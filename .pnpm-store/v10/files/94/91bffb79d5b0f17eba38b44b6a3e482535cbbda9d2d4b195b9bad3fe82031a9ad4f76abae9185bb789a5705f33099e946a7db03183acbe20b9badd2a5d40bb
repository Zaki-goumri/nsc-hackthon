{
  "version": 3,
  "sources": ["../../../../src/schemas/3.1/compliance/runtime-expression.test.ts"],
  "sourcesContent": ["import { describe, expect, it } from 'vitest'\n\nimport { RuntimeExpressionSchema } from '../unprocessed/runtime-expression'\n\ndescribe('RuntimeExpressionSchema', () => {\n  describe('validation', () => {\n    // Valid expressions\n    const validExpressions = [\n      {\n        expression: '$url',\n        description: 'validates $url expression',\n      },\n      {\n        expression: '$method',\n        description: 'validates $method expression',\n      },\n      {\n        expression: '$statusCode',\n        description: 'validates $statusCode expression',\n      },\n      {\n        expression: '$request.path.id',\n        description: 'validates path parameter reference',\n      },\n      {\n        expression: '$request.query.filter',\n        description: 'validates query parameter reference',\n      },\n      {\n        expression: '$request.header.X-Custom-Header',\n        description: 'validates header reference',\n      },\n      {\n        expression: '$request.body#/user/id',\n        description: 'validates body reference with JSON pointer',\n      },\n      {\n        expression: '$response.header.Content-Type',\n        description: 'validates response header reference',\n      },\n      {\n        expression: '$response.body#/status',\n        description: 'validates response body reference with JSON pointer',\n      },\n      {\n        expression: 'http://notificationServer.com?transactionId={$request.body#/id}&email={$request.body#/email}',\n        description: 'validates URL with runtime expressions',\n      },\n      {\n        expression: '{$request.query.queryUrl}',\n        description: 'validates URL with runtime expressions',\n      },\n    ]\n\n    validExpressions.forEach(({ expression, description }) => {\n      it(description, () => {\n        expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n      })\n    })\n\n    // Invalid expressions\n    const invalidExpressions = [\n      {\n        expression: 'invalid',\n        description: 'rejects expression without $ prefix',\n      },\n      {\n        expression: '$invalid',\n        description: 'rejects unknown runtime expression',\n      },\n      {\n        expression: '$request.invalid.field',\n        description: 'rejects invalid request field reference',\n      },\n      {\n        expression: '$response.invalid.field',\n        description: 'rejects invalid response field reference',\n      },\n      {\n        expression: '$request.body#invalid-pointer',\n        description: 'rejects invalid JSON pointer syntax',\n      },\n      {\n        expression: '',\n        description: 'rejects empty string',\n      },\n    ]\n\n    invalidExpressions.forEach(({ expression, description }) => {\n      it(description, () => {\n        expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(false)\n      })\n    })\n  })\n\n  describe('complex expressions', () => {\n    it('validates nested JSON pointers', () => {\n      const expression = '$request.body#/user/addresses/0/street'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n    })\n\n    it('validates case-sensitive header names', () => {\n      const expression = '$request.header.Content-Type'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n    })\n\n    it('validates expressions with special characters in JSON pointers', () => {\n      const expression = '$response.body#/data/special~1field/value'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n    })\n  })\n\n  describe('edge cases', () => {\n    it('validates empty JSON pointer', () => {\n      const expression = '$request.body#'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n    })\n\n    it('validates root JSON pointer', () => {\n      const expression = '$response.body#/'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n    })\n\n    it('handles whitespace in header names', () => {\n      const expression = '$request.header.X-Custom Header'\n      expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(false)\n    })\n  })\n\n  describe('embedded expressions', () => {\n    const validEmbeddedExpressions = [\n      {\n        expression: 'Hello {$request.body#/name}!',\n        description: 'validates simple embedded expression',\n      },\n      {\n        expression: 'User {$request.path.id} updated at {$request.body#/timestamp}',\n        description: 'validates multiple embedded expressions',\n      },\n      {\n        expression: 'Status: {$statusCode}',\n        description: 'validates embedded system variable',\n      },\n      {\n        expression: '{$request.header.Authorization}',\n        description: 'validates single embedded expression',\n      },\n      {\n        expression: 'Content-Type is: {$response.header.Content-Type}',\n        description: 'validates embedded header reference',\n      },\n    ]\n\n    validEmbeddedExpressions.forEach(({ expression, description }) => {\n      it(description, () => {\n        expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(true)\n      })\n    })\n\n    const invalidEmbeddedExpressions = [\n      {\n        expression: 'Missing closing brace {$request.body#/name',\n        description: 'rejects unclosed embedded expression',\n      },\n      {\n        expression: 'Missing opening brace $request.body#/name}',\n        description: 'rejects unopened embedded expression',\n      },\n      {\n        expression: 'Empty braces {}',\n        description: 'rejects empty embedded expression',\n      },\n    ]\n\n    invalidEmbeddedExpressions.forEach(({ expression, description }) => {\n      it(description, () => {\n        expect(RuntimeExpressionSchema.safeParse(expression).success).toBe(false)\n      })\n    })\n  })\n})\n"],
  "mappings": "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",
  "names": []
}
